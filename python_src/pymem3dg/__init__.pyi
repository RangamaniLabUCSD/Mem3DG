from typing import Any, Callable, List, Tuple

from typing import overload
import flags
import numpy
import scipy.sparse

class Adsorption:
    epsilon: float
    def __init__(self, *args, **kwargs) -> None: ...

class Aggregation:
    chi: float
    def __init__(self, *args, **kwargs) -> None: ...

class Bending:
    D: float
    H0c: float
    Kb: float
    Kbc: float
    Kd: float
    Kdc: float
    alpha: float
    dA0: float
    relation: str
    def __init__(self) -> None: ...

class Boundary:
    proteinBoundaryCondition: str
    shapeBoundaryCondition: str
    def __init__(self) -> None: ...

class ConjugateGradient:
    c1: float
    constraintTolerance: float
    ifAdaptiveStep: bool
    ifJustGeometryPly: bool
    ifOutputMeshFile: bool
    ifOutputTrajFile: bool
    ifPrintToConsole: bool
    isAugementedLagrangian: bool
    isBacktrack: bool
    outputDirectory: str
    restartPeriod: int
    rho: float
    trajFileName: str
    def __init__(
        self,
        system,
        characteristicTimeStep: float,
        totalTime: float,
        savePeriod: float,
        tolerance: float,
        outputDirectory: str,
        frame: int = ...,
    ) -> None: ...
    def integrate(self) -> bool: ...
    def march(self) -> None: ...
    def saveData(
        self, ifOutputTrajFile: bool, ifOutputMeshFile: bool, ifPrintToConsole: bool
    ) -> None: ...
    def status(self) -> None: ...
    def step(self, n: int) -> None: ...
    @property
    def characteristicTimeStep(self) -> float: ...
    @property
    def savePeriod(self) -> float: ...
    @property
    def tolerance(self) -> float: ...
    @property
    def totalTime(self) -> float: ...

class DPD:
    gamma: float
    def __init__(self, *args, **kwargs) -> None: ...

class Dirichlet:
    eta: float
    def __init__(self, *args, **kwargs) -> None: ...

class Energy:
    def __init__(self) -> None: ...
    @property
    def adsorptionEnergy(self) -> float: ...
    @property
    def aggregationEnergy(self) -> float: ...
    @property
    def areaDifferenceEnergy(self) -> float: ...
    @property
    def deviatoricCurvatureEnergy(self) -> float: ...
    @property
    def dirichletEnergy(self) -> float: ...
    @property
    def edgeSpringEnergy(self) -> float: ...
    @property
    def entropyEnergy(self) -> float: ...
    @property
    def externalWork(self) -> float: ...
    @property
    def faceSpringEnergy(self) -> float: ...
    @property
    def kineticEnergy(self) -> float: ...
    @property
    def lcrSpringEnergy(self) -> float: ...
    @property
    def potentialEnergy(self) -> float: ...
    @property
    def pressureEnergy(self) -> float: ...
    @property
    def proteinInteriorPenalty(self) -> float: ...
    @property
    def spontaneousCurvatureEnergy(self) -> float: ...
    @property
    def surfaceEnergy(self) -> float: ...
    @property
    def totalEnergy(self) -> float: ...

class Entropy:
    xi: float
    def __init__(self, *args, **kwargs) -> None: ...

class Euler:
    c1: float
    ifAdaptiveStep: bool
    ifJustGeometryPly: bool
    ifOutputMeshFile: bool
    ifOutputTrajFile: bool
    ifPrintToConsole: bool
    isBacktrack: bool
    outputDirectory: str
    rho: float
    trajFileName: str
    @overload
    def __init__(
        self,
        system,
        characteristicTimeStep: float,
        totalTime: float,
        savePeriod: float,
        tolerance: float,
        outputDirectory: str,
        frame: int = ...,
    ) -> None: ...
    @overload
    def __init__(
        self,
        system,
        characteristicTimeStep: float,
        tolerance: float,
        outputDirectory: str,
    ) -> None: ...
    def closeMutableNetcdfFile(self) -> None: ...
    def createMutableNetcdfFile(self, isContinue: bool) -> None: ...
    def integrate(self) -> bool: ...
    def march(self) -> None: ...
    def saveData(
        self, ifOutputTrajFile: bool, ifOutputMeshFile: bool, ifPrintToConsole: bool
    ) -> None: ...
    def saveMutableNetcdfData(self) -> None: ...
    def status(self) -> None: ...
    def step(self, n: int) -> None: ...
    @property
    def EXIT(self) -> bool: ...
    @property
    def characteristicTimeStep(self) -> float: ...
    @property
    def savePeriod(self) -> float: ...
    @property
    def timeStep(self) -> float: ...
    @property
    def tolerance(self) -> float: ...
    @property
    def totalTime(self) -> float: ...

class External:
    form: Callable[
        [
            numpy.ndarray[numpy.float64[m, 3]],
            numpy.ndarray[numpy.float64[m, 1]],
            float,
            numpy.ndarray[numpy.float64[m, 1]],
        ],
        numpy.ndarray[numpy.float64[m, 3]],
    ]
    def __init__(self, *args, **kwargs) -> None: ...

class Forces:
    def __init__(self, *args, **kwargs) -> None: ...
    def getAdsorptionForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getAdsorptionPotential(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getAggregationForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getAggregationPotential(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getAreaDifferenceForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getCapillaryForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getChemicalPotential(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getDeviatoricCurvatureForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getDeviatoricCurvaturePotential(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getDirichletPotential(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getEntropyForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getEntropyPotential(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getExternalForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getInteriorPenaltyPotential(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getLineCapillaryForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getMechanicalForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getOsmoticForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getOsmoticPressure(self) -> float: ...
    def getSpontaneousCurvatureForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getSpontaneousCurvatureForceVec_areaGrad(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getSpontaneousCurvatureForceVec_gaussVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getSpontaneousCurvatureForceVec_schlafliVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getSpontaneousCurvaturePotential(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getSpringForceVec(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getSurfaceTension(self) -> float: ...

class Geometry:
    @overload
    def __init__(
        self,
        inputMesh: str,
        referenceMesh: str,
        notableVertex: numpy.ndarray[bool[m, 1]],
    ) -> None: ...
    @overload
    def __init__(self, inputMesh: str, referenceMesh: str) -> None: ...
    @overload
    def __init__(
        self,
        faceMatrix: numpy.ndarray[numpy.uint64[m, 3]],
        vertexMatrix: numpy.ndarray[numpy.float64[m, 3]],
        referenceVertexMatrix: numpy.ndarray[numpy.float64[m, 3]],
        notableVertex: numpy.ndarray[bool[m, 1]],
    ) -> None: ...
    @overload
    def __init__(
        self,
        faceMatrix: numpy.ndarray[numpy.uint64[m, 3]],
        vertexMatrix: numpy.ndarray[numpy.float64[m, 3]],
        referenceVertexMatrix: numpy.ndarray[numpy.float64[m, 3]],
    ) -> None: ...
    @overload
    def __init__(self, trajFile: str, startingFrame: int) -> None: ...
    def computeGeodesicDistance(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getCotanLaplacian(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def getEdgeAdjacencyMatrix(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def getEdgeLengths(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getFaceMatrix(self) -> numpy.ndarray[numpy.uint64[m, n]]: ...
    def getGeodesicDistance(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getLumpedMassMatrix(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def getNotableVertex(self) -> numpy.ndarray[bool[m, 1]]: ...
    def getPolyscopeEdgeOrientations(self) -> numpy.ndarray[numpy.int8[m, 1]]: ...
    def getPolyscopePermutations(self) -> List[Tuple[List[int], int][5]]: ...
    def getSurfaceArea(self) -> float: ...
    def getVertexAdjacencyMatrix(self) -> scipy.sparse.csc_matrix[numpy.float64]: ...
    def getVertexDualAreas(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getVertexGaussianCurvatureVectors(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getVertexGaussianCurvatures(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getVertexMatrix(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getVertexMeanCurvatureVectors(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getVertexMeanCurvatures(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getVertexNormals(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getVertexSchlafliLaplacianMeanCurvatureVectors(
        self, arg0: numpy.ndarray[numpy.float64[m, 1]]
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getVertexVolumeVariationVectors(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def getVolume(self) -> float: ...
    def setInputVertexPositions(
        self, arg0: numpy.ndarray[numpy.float64[m, 3]]
    ) -> None: ...

class MeshMutator:
    collapseFlat: bool
    collapseSkinny: bool
    collapseSmall: bool
    curvTol: float
    flipNonDelaunay: bool
    flipNonDelaunayRequireFlat: bool
    isShiftVertex: bool
    isSmoothenMesh: bool
    maximumEdgeLength: float
    minimumEdgeLength: float
    mutateMeshPeriod: int
    splitCurved: bool
    splitFat: bool
    splitLarge: bool
    splitLong: bool
    splitSharp: bool
    splitSkinnyDelaunay: bool
    targetFaceArea: float
    def __init__(self) -> None: ...
    @property
    def isChangeTopology(self) -> bool: ...
    @property
    def isCollapseEdge(self) -> bool: ...
    @property
    def isFlipEdge(self) -> bool: ...
    @property
    def isSplitEdge(self) -> bool: ...

class MeshProcessor:
    meshMutator: MeshMutator
    def __init__(self) -> None: ...
    @property
    def isMeshMutate(self) -> bool: ...

class Osmotic:
    form: Callable[[float], Tuple[float, float]]
    def __init__(self, *args, **kwargs) -> None: ...

class Parameters:
    adsorption: Adsorption
    aggregation: Aggregation
    bending: Bending
    boundary: Boundary
    damping: float
    dirichlet: Dirichlet
    dpd: DPD
    entropy: Entropy
    external: External
    osmotic: Osmotic
    point: Point
    protein: Protein
    proteinMobility: float
    selfAvoidance: SelfAvoidance
    spring: spring
    temperature: float
    tension: Tension
    variation: Variation
    def __init__(self) -> None: ...

class Point:
    prescribeNotableVertex: Callable[
        [
            numpy.ndarray[numpy.uint64[m, 3]],
            numpy.ndarray[numpy.float64[m, 3]],
            numpy.ndarray[numpy.float64[m, 1]],
        ],
        numpy.ndarray[bool[m, 1]],
    ]
    updateGeodesicsPeriod: int
    updateNotableVertexPeriod: int
    def __init__(self, *args, **kwargs) -> None: ...

class Protein:
    prescribeProteinDensityDistribution: Callable[
        [float, numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[numpy.float64[m, 1]]],
        numpy.ndarray[numpy.float64[m, 1]],
    ]
    proteinInteriorPenalty: float
    updateProteinDensityDistributionPeriod: int
    def __init__(self, *args, **kwargs) -> None: ...

class SelfAvoidance:
    d: float
    mu: float
    n: int
    p: float
    def __init__(self, *args, **kwargs) -> None: ...

class System:
    meshProcessor: MeshProcessor
    parameters: Any
    time: float
    @overload
    def __init__(
        self,
        geometry: Geometry,
        proteinDensity: numpy.ndarray[numpy.float64[m, 1]],
        velocity: numpy.ndarray[numpy.float64[m, 3]],
        parameters,
        time: float = ...,
    ) -> None: ...
    @overload
    def __init__(self, geometry: Geometry, parameters, time: float = ...) -> None: ...
    @overload
    def __init__(
        self, geometry: Geometry, trajFile: str, startingFrame: int, parameters
    ) -> None: ...
    def addNonconservativeForcing(self, timeStep: float = ...) -> None: ...
    def computeConservativeForcing(self) -> None: ...
    def computeInPlaneFluxForm(
        self, chemicalPotential: numpy.ndarray[numpy.float64[m, 1]]
    ) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def computeIntegratedPower(self, dt: float) -> float: ...
    def computeTotalEnergy(self) -> float: ...
    def getEnergy(self, *args, **kwargs) -> Any: ...
    def getForces(self) -> Forces: ...
    def getGeometry(self) -> Geometry: ...
    def getProteinDensity(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getProteinRateOfChange(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getSpontaneousCurvature(self) -> numpy.ndarray[numpy.float64[m, 1]]: ...
    def getVelocity(
        self,
    ) -> numpy.ndarray[numpy.float64[m, 3], flags.writeable, flags.c_contiguous]: ...
    def initialize(self, ifMutateMesh: bool = ..., ifMute: bool = ...) -> None: ...
    def mutateMesh(self, nMutation: int = ...) -> None: ...
    def prescribeExternalForce(self) -> numpy.ndarray[numpy.float64[m, 3]]: ...
    def saveRichData(self, pathToSave: str, isJustGeometry: bool = ...) -> None: ...
    def smoothenMesh(
        self, initStep: float, target: float, maxIteration: int
    ) -> numpy.ndarray[bool[m, 1]]: ...
    def testConservativeForcing(self, timeStep: float) -> bool: ...
    def updateConfigurations(self) -> None: ...

class Tension:
    form: Callable[[float], Tuple[float, float]]
    def __init__(self) -> None: ...

class Variation:
    geodesicMask: float
    isProteinConservation: bool
    isProteinVariation: bool
    isShapeVariation: bool
    updateMaskPeriod: int
    def __init__(self) -> None: ...

class VelocityVerlet:
    c1: float
    ifAdaptiveStep: bool
    ifOutputMeshFile: bool
    ifOutputTrajFile: bool
    ifPrintToConsole: bool
    isBacktrack: bool
    isCapEnergy: bool
    outputDirectory: str
    rho: float
    trajFileName: str
    def __init__(
        self,
        system,
        characteristicTimeStep: float,
        totalTime: float,
        savePeriod: float,
        tolerance: float,
        outputDirectory: str,
        frame: int = ...,
    ) -> None: ...
    def integrate(self) -> bool: ...
    def march(self) -> None: ...
    def saveData(
        self, ifOutputTrajFile: bool, ifOutputMeshFile: bool, ifPrintToConsole: bool
    ) -> None: ...
    def status(self) -> None: ...
    def step(self, n: int) -> None: ...

class spring:
    Kse: float
    Ksl: float
    Kst: float
    def __init__(self, *args, **kwargs) -> None: ...

def getCylinder(
    radius: float,
    radialSubdivision: int,
    axialSubdivision: int,
    frequency: float = ...,
    amplitude: float = ...,
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
def getData(
    plyName: str, elementName: str, propertyName: str
) -> numpy.ndarray[numpy.float64[m, 1]]: ...
def getDataElementName(plyName: str) -> List[str]: ...
def getDataPropertyName(plyName: str, elementName: str) -> List[str]: ...
def getDiamond(
    dihedral: float,
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
def getFaceAndVertexMatrix(
    plyName: str,
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
def getFaceSurfacePointClosestToEmbeddedCoordinate(
    faceMatrix: numpy.ndarray[numpy.uint64[m, 3]],
    vertexMatrix: numpy.ndarray[numpy.float64[m, 3]],
    embeddedCoordinate: List[float[3]],
    filter: numpy.ndarray[bool[m, 1]],
    accountedCoordinate: List[bool[3]] = ...,
) -> Tuple[int, List[float[3]]]: ...
def getHexagon(
    radius: float, subdivision: int = ...
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
def getIcosphere(
    radius: float, subdivision: int = ...
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
def getTetrahedron() -> (
    Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]
): ...
def getVertexClosestToEmbeddedCoordinate(
    vertexMatrix: numpy.ndarray[numpy.float64[m, 3]],
    embeddedCoordinate: List[float[3]],
    filter: numpy.ndarray[bool[m, 1]],
    accountedCoordinate: List[bool[3]] = ...,
) -> int: ...
def getVertexFurthestFromBoundary(
    faceMatrix: numpy.ndarray[numpy.uint64[m, 3]],
    vertexMatrix: numpy.ndarray[numpy.float64[m, 3]],
) -> int: ...
def linearSubdivide(
    face: numpy.ndarray[numpy.uint64[m, 3]],
    vertex: numpy.ndarray[numpy.float64[m, 3]],
    nSub: int,
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
def loopSubdivide(
    face: numpy.ndarray[numpy.uint64[m, 3]],
    vertex: numpy.ndarray[numpy.float64[m, 3]],
    nSub: int,
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
def processSoup(
    meshName: str,
) -> Tuple[numpy.ndarray[numpy.uint64[m, 3]], numpy.ndarray[numpy.float64[m, 3]]]: ...
