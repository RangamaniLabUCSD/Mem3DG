<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mem3DG: mem3dg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mem3DG
   &#160;<span id="projectnumber">v0.0.6-rc3</span>
   </div>
   <div id="projectbrief">Membrane Dynamics in 3D using Discrete Differential Geometry</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mem3dg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Mem3dg namespace.  
<a href="namespacemem3dg.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemem3dg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacemem3dg_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">detail namespace <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemem3dg_1_1solver"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg_1_1solver.html">solver</a></td></tr>
<tr class="memdesc:namespacemem3dg_1_1solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">solver namespace <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afdb5fe05634cca4cd4d6ad809f364053"><td class="memItemLeft" align="right" valign="top"><a id="afdb5fe05634cca4cd4d6ad809f364053"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenVectorX1d</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:afdb5fe05634cca4cd4d6ad809f364053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e73eccd88a9a1ce43fd090d2cb33b6"><td class="memTemplParams" colspan="2"><a id="ac2e73eccd88a9a1ce43fd090d2cb33b6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2e73eccd88a9a1ce43fd090d2cb33b6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenVectorX1_T</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:ac2e73eccd88a9a1ce43fd090d2cb33b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c59ecbcaef37365edf0d9009db9fe4"><td class="memItemLeft" align="right" valign="top"><a id="ac3c59ecbcaef37365edf0d9009db9fe4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenVectorX1i</b> = Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:ac3c59ecbcaef37365edf0d9009db9fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889deef6a76cd1f5995b3557719b45c7"><td class="memItemLeft" align="right" valign="top"><a id="a889deef6a76cd1f5995b3557719b45c7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenVectorX3dr</b> = Eigen::Matrix&lt; double, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a889deef6a76cd1f5995b3557719b45c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f770c0d5471de6f93cb00dc8e906e0"><td class="memItemLeft" align="right" valign="top"><a id="a21f770c0d5471de6f93cb00dc8e906e0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenVectorX3ur</b> = Eigen::Matrix&lt; std::uint32_t, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a21f770c0d5471de6f93cb00dc8e906e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ab7453d454251fe933b6827c0d1d66"><td class="memItemLeft" align="right" valign="top"><a id="aa5ab7453d454251fe933b6827c0d1d66"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenVectorX3u</b> = Eigen::Matrix&lt; std::uint32_t, Eigen::Dynamic, 3 &gt;</td></tr>
<tr class="separator:aa5ab7453d454251fe933b6827c0d1d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb531d0966652519940f2ed326fbd87"><td class="memItemLeft" align="right" valign="top"><a id="aacb531d0966652519940f2ed326fbd87"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenVectorX3sr</b> = Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:aacb531d0966652519940f2ed326fbd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e7b99a75084a165f028b34c27075c5"><td class="memItemLeft" align="right" valign="top"><a id="a55e7b99a75084a165f028b34c27075c5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EigenVectorX3s</b> = Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;</td></tr>
<tr class="separator:a55e7b99a75084a165f028b34c27075c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b833b053cf400aa5a56d7bb585b29"><td class="memTemplParams" colspan="2"><a id="a5c0b833b053cf400aa5a56d7bb585b29"></a>
template&lt;typename T , int k&gt; </td></tr>
<tr class="memitem:a5c0b833b053cf400aa5a56d7bb585b29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenVectorXkr_T</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, k, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a5c0b833b053cf400aa5a56d7bb585b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1bfded48c3668f9b21cc259437fb7a"><td class="memTemplParams" colspan="2"><a id="a4c1bfded48c3668f9b21cc259437fb7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4c1bfded48c3668f9b21cc259437fb7a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a> = std::vector&lt; T, Eigen::aligned_allocator&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a4c1bfded48c3668f9b21cc259437fb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for aligned vectors. <br /></td></tr>
<tr class="separator:a4c1bfded48c3668f9b21cc259437fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18a4bfe1760e62b47f5c672c4e6ccb9"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t k, int Options = Eigen::ColMajor&gt; </td></tr>
<tr class="memitem:ac18a4bfe1760e62b47f5c672c4e6ccb9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a> = Eigen::Map&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, k, Options &gt;, Eigen::AlignedMax &gt;</td></tr>
<tr class="memdesc:ac18a4bfe1760e62b47f5c672c4e6ccb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typename for an Eigen map to an aligned raw buffer.  <a href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">More...</a><br /></td></tr>
<tr class="separator:ac18a4bfe1760e62b47f5c672c4e6ccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9360091ae70efb3cb3ee7f85210c3a7"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t k, int Options = Eigen::ColMajor&gt; </td></tr>
<tr class="memitem:ad9360091ae70efb3cb3ee7f85210c3a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a> = Eigen::Map&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, k, Options &gt;, Eigen::AlignedMax &gt;</td></tr>
<tr class="memdesc:ad9360091ae70efb3cb3ee7f85210c3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typename for an Eigen map to a const aligned raw buffer.  <a href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">More...</a><br /></td></tr>
<tr class="separator:ad9360091ae70efb3cb3ee7f85210c3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abf447d558909b0aa3d2ec070acb82614"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:abf447d558909b0aa3d2ec070acb82614"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#abf447d558909b0aa3d2ec070acb82614">rowwiseDotProduct</a> (const Eigen::DenseBase&lt; DerivedA &gt; &amp;A, const Eigen::DenseBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:abf447d558909b0aa3d2ec070acb82614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rowwise dot product between two Eigen Matrices.  <a href="namespacemem3dg.html#abf447d558909b0aa3d2ec070acb82614">More...</a><br /></td></tr>
<tr class="separator:abf447d558909b0aa3d2ec070acb82614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89367de57a1fb9f6a7399ac1f191be5d"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename Derived &gt; </td></tr>
<tr class="memitem:a89367de57a1fb9f6a7399ac1f191be5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a89367de57a1fb9f6a7399ac1f191be5d">rowwiseScalarProduct</a> (const Eigen::DenseBase&lt; VectorType &gt; &amp;A, const Eigen::DenseBase&lt; Derived &gt; &amp;B)</td></tr>
<tr class="memdesc:a89367de57a1fb9f6a7399ac1f191be5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rowwise scalar product between a matrix and scalar.  <a href="namespacemem3dg.html#a89367de57a1fb9f6a7399ac1f191be5d">More...</a><br /></td></tr>
<tr class="separator:a89367de57a1fb9f6a7399ac1f191be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1188f5bd2efed53cb4b223e12d4c22d1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1188f5bd2efed53cb4b223e12d4c22d1"><td class="memTemplItemLeft" align="right" valign="top">Derived::PlainMatrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a1188f5bd2efed53cb4b223e12d4c22d1">rowwiseCrossProduct</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;A, const Eigen::DenseBase&lt; Derived &gt; &amp;B)</td></tr>
<tr class="memdesc:a1188f5bd2efed53cb4b223e12d4c22d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rowwise cross product between two matrices.  <a href="namespacemem3dg.html#a1188f5bd2efed53cb4b223e12d4c22d1">More...</a><br /></td></tr>
<tr class="separator:a1188f5bd2efed53cb4b223e12d4c22d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530446a95ff172c5c99a0c66a193d787"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t k, typename O , int Options = Eigen::RowMajor&gt; </td></tr>
<tr class="memitem:a530446a95ff172c5c99a0c66a193d787"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt; T, k, Options &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a530446a95ff172c5c99a0c66a193d787">EigenMap</a> (<a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;vec)</td></tr>
<tr class="memdesc:a530446a95ff172c5c99a0c66a193d787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an Eigen Map to an aligned raw buffer.  <a href="namespacemem3dg.html#a530446a95ff172c5c99a0c66a193d787">More...</a><br /></td></tr>
<tr class="separator:a530446a95ff172c5c99a0c66a193d787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405d04529e1fbbd4963bac9e4ec22443"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t k, typename O , int Options = Eigen::RowMajor&gt; </td></tr>
<tr class="memitem:a405d04529e1fbbd4963bac9e4ec22443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt; T, k, Options &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a405d04529e1fbbd4963bac9e4ec22443">EigenMap</a> (const <a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;vec)</td></tr>
<tr class="memdesc:a405d04529e1fbbd4963bac9e4ec22443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an Eigen Map to a const aligned raw buffer.  <a href="namespacemem3dg.html#a405d04529e1fbbd4963bac9e4ec22443">More...</a><br /></td></tr>
<tr class="separator:a405d04529e1fbbd4963bac9e4ec22443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef136cba4f1f788cc54bde34c6fa1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af0ef136cba4f1f788cc54bde34c6fa1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#af0ef136cba4f1f788cc54bde34c6fa1e">EigenMap</a> (<a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:af0ef136cba4f1f788cc54bde34c6fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an Eigen Map to an aligned raw buffer.  <a href="namespacemem3dg.html#af0ef136cba4f1f788cc54bde34c6fa1e">More...</a><br /></td></tr>
<tr class="separator:af0ef136cba4f1f788cc54bde34c6fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ffb09c24a72ea4d8dbbf64e43560ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55ffb09c24a72ea4d8dbbf64e43560ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a55ffb09c24a72ea4d8dbbf64e43560ed">EigenMap</a> (const <a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a55ffb09c24a72ea4d8dbbf64e43560ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an Eigen Map to an aligned raw buffer.  <a href="namespacemem3dg.html#a55ffb09c24a72ea4d8dbbf64e43560ed">More...</a><br /></td></tr>
<tr class="separator:a55ffb09c24a72ea4d8dbbf64e43560ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3954854d155a2c2e73daaba157bda79e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t k, typename O &gt; </td></tr>
<tr class="memitem:a3954854d155a2c2e73daaba157bda79e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a3954854d155a2c2e73daaba157bda79e">FlattenedEigenMap</a> (<a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;vec)</td></tr>
<tr class="memdesc:a3954854d155a2c2e73daaba157bda79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an Eigen Map to an aligned raw buffer.  <a href="namespacemem3dg.html#a3954854d155a2c2e73daaba157bda79e">More...</a><br /></td></tr>
<tr class="separator:a3954854d155a2c2e73daaba157bda79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e74c89ae7c026d3f7195fe8726188"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t k, typename O &gt; </td></tr>
<tr class="memitem:a5a5e74c89ae7c026d3f7195fe8726188"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt; T, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a5a5e74c89ae7c026d3f7195fe8726188">FlattenedEigenMap</a> (const <a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;vec)</td></tr>
<tr class="memdesc:a5a5e74c89ae7c026d3f7195fe8726188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate an Eigen Map to an aligned raw buffer.  <a href="namespacemem3dg.html#a5a5e74c89ae7c026d3f7195fe8726188">More...</a><br /></td></tr>
<tr class="separator:a5a5e74c89ae7c026d3f7195fe8726188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3679a03c05b9b303f60e3a103b02d478"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a3679a03c05b9b303f60e3a103b02d478"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt; typename Derived::Scalar, 1, Eigen::ColMajor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a3679a03c05b9b303f60e3a103b02d478">flatten</a> (Eigen::DenseBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:a3679a03c05b9b303f60e3a103b02d478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a NxK row matrix into KNx1.  <a href="namespacemem3dg.html#a3679a03c05b9b303f60e3a103b02d478">More...</a><br /></td></tr>
<tr class="separator:a3679a03c05b9b303f60e3a103b02d478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78531a57b0526c565190e07c3a89b69"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa78531a57b0526c565190e07c3a89b69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt; typename Derived::Scalar, 1, Eigen::ColMajor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#aa78531a57b0526c565190e07c3a89b69">flatten</a> (const Eigen::DenseBase&lt; const Derived &gt; &amp;matrix)</td></tr>
<tr class="memdesc:aa78531a57b0526c565190e07c3a89b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten a NxK row matrix into KNx1.  <a href="namespacemem3dg.html#aa78531a57b0526c565190e07c3a89b69">More...</a><br /></td></tr>
<tr class="separator:aa78531a57b0526c565190e07c3a89b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5ddc7ee703e3467c8eb32c1d7290b7"><td class="memTemplParams" colspan="2"><a id="a1d5ddc7ee703e3467c8eb32c1d7290b7"></a>
template&lt;std::size_t k, typename Derived &gt; </td></tr>
<tr class="memitem:a1d5ddc7ee703e3467c8eb32c1d7290b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt; typename Derived::Scalar, k, Eigen::RowMajor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unflatten</b> (Eigen::DenseBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="separator:a1d5ddc7ee703e3467c8eb32c1d7290b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91d28607ce0320980bce83696e2e577"><td class="memTemplParams" colspan="2"><a id="ac91d28607ce0320980bce83696e2e577"></a>
template&lt;std::size_t k, typename Derived &gt; </td></tr>
<tr class="memitem:ac91d28607ce0320980bce83696e2e577"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt; typename Derived::Scalar, k, Eigen::RowMajor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>unflatten</b> (const Eigen::DenseBase&lt; Derived &gt; &amp;matrix)</td></tr>
<tr class="separator:ac91d28607ce0320980bce83696e2e577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb017d8016270ece9cec6fa8926483df"><td class="memItemLeft" align="right" valign="top"><a id="adb017d8016270ece9cec6fa8926483df"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>toMatrix</b> (gcs::VertexData&lt; gc::Vector3 &gt; &amp;vector)</td></tr>
<tr class="separator:adb017d8016270ece9cec6fa8926483df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ab9afa972ce74cef7bae4ca09ac7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a7c2ab9afa972ce74cef7bae4ca09ac7f">sortVector</a> (const Eigen::VectorXd &amp;vec, Eigen::VectorXd &amp;sorted_vec, Eigen::VectorXi &amp;ind)</td></tr>
<tr class="memdesc:a7c2ab9afa972ce74cef7bae4ca09ac7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort Eigen vector from largest to smallest.  <a href="namespacemem3dg.html#a7c2ab9afa972ce74cef7bae4ca09ac7f">More...</a><br /></td></tr>
<tr class="separator:a7c2ab9afa972ce74cef7bae4ca09ac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4833942188b5e9e6ff0a3723b423ddcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a4833942188b5e9e6ff0a3723b423ddcf">sortVector</a> (const Eigen::VectorXd &amp;vec, Eigen::VectorXd &amp;sorted_vec)</td></tr>
<tr class="memdesc:a4833942188b5e9e6ff0a3723b423ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort Eigen vector from largest to smallest (overloaded)  <a href="namespacemem3dg.html#a4833942188b5e9e6ff0a3723b423ddcf">More...</a><br /></td></tr>
<tr class="separator:a4833942188b5e9e6ff0a3723b423ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f6703fb26f37bc4b77007e4204ceda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ad6f6703fb26f37bc4b77007e4204ceda">findMedianIndex</a> (int l, int r)</td></tr>
<tr class="memdesc:ad6f6703fb26f37bc4b77007e4204ceda"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the middle index between two bounding indices  <a href="namespacemem3dg.html#ad6f6703fb26f37bc4b77007e4204ceda">More...</a><br /></td></tr>
<tr class="separator:ad6f6703fb26f37bc4b77007e4204ceda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa60ad9c6289417135e4c03ef3948c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a7fa60ad9c6289417135e4c03ef3948c9">findRange</a> (double *a, int n, double &amp;r, double &amp;l)</td></tr>
<tr class="memdesc:a7fa60ad9c6289417135e4c03ef3948c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the range of data based on percentile (quartile)  <a href="namespacemem3dg.html#a7fa60ad9c6289417135e4c03ef3948c9">More...</a><br /></td></tr>
<tr class="separator:a7fa60ad9c6289417135e4c03ef3948c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cce18eb8259594b2540130536a38b2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a5cce18eb8259594b2540130536a38b2a">hasOutlier</a> (const Eigen::VectorXd &amp;vec, double threshold=0.5)</td></tr>
<tr class="memdesc:a5cce18eb8259594b2540130536a38b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">test whether exist outliers to the set of data based range function  <a href="namespacemem3dg.html#a5cce18eb8259594b2540130536a38b2a">More...</a><br /></td></tr>
<tr class="separator:a5cce18eb8259594b2540130536a38b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac11c7670c0c87458b6aa536bb58c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> EigenVectorX1_T&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a5ac11c7670c0c87458b6aa536bb58c09">outlierMask</a> (const EigenVectorX1d &amp;vec, double threshold=0.5, bool negate=false)</td></tr>
<tr class="memdesc:a5ac11c7670c0c87458b6aa536bb58c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">test whether exist outliers to the set of data based range function  <a href="namespacemem3dg.html#a5ac11c7670c0c87458b6aa536bb58c09">More...</a><br /></td></tr>
<tr class="separator:a5ac11c7670c0c87458b6aa536bb58c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02025472dcee4fd1274df12f2501db0c"><td class="memItemLeft" align="right" valign="top"><a id="a02025472dcee4fd1274df12f2501db0c"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a02025472dcee4fd1274df12f2501db0c">signalHandler</a> (int signum)</td></tr>
<tr class="memdesc:a02025472dcee4fd1274df12f2501db0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal handler for pybind. <br /></td></tr>
<tr class="separator:a02025472dcee4fd1274df12f2501db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95cce8740048b09b90913fc1abba85c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ac95cce8740048b09b90913fc1abba85c">signedVolumeFromFace</a> (gc::Vector3 &amp;p0, gc::Vector3 &amp;p1, gc::Vector3 &amp;p2)</td></tr>
<tr class="memdesc:ac95cce8740048b09b90913fc1abba85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get volume from a face.  <a href="namespacemem3dg.html#ac95cce8740048b09b90913fc1abba85c">More...</a><br /></td></tr>
<tr class="separator:ac95cce8740048b09b90913fc1abba85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752c67228a9ebe0e45ab6a85b1ab1350"><td class="memItemLeft" align="right" valign="top"><a id="a752c67228a9ebe0e45ab6a85b1ab1350"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>signedVolumeFromFace</b> (gcs::Vertex &amp;&amp;v0, gcs::Vertex &amp;&amp;v1, gcs::Vertex &amp;v2, gcs::VertexPositionGeometry &amp;vpg)</td></tr>
<tr class="separator:a752c67228a9ebe0e45ab6a85b1ab1350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9a9e8d66c7e54eb79f98dc621a5b24"><td class="memItemLeft" align="right" valign="top"><a id="a9a9a9e8d66c7e54eb79f98dc621a5b24"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>signedVolumeFromFace</b> (gcs::Face &amp;f, gcs::VertexPositionGeometry &amp;vpg)</td></tr>
<tr class="separator:a9a9a9e8d66c7e54eb79f98dc621a5b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b23a08e81f455399546903f396a1135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a5b23a08e81f455399546903f396a1135">getMeshVolume</a> (gcs::ManifoldSurfaceMesh &amp;mesh, gcs::VertexPositionGeometry &amp;vpg, bool isFillHole=true)</td></tr>
<tr class="memdesc:a5b23a08e81f455399546903f396a1135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the volume of a mesh object.  <a href="namespacemem3dg.html#a5b23a08e81f455399546903f396a1135">More...</a><br /></td></tr>
<tr class="separator:a5b23a08e81f455399546903f396a1135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52599d1cf03bba33033581bdc5d2727"><td class="memTemplParams" colspan="2">template&lt;typename E , typename T &gt; </td></tr>
<tr class="memitem:ad52599d1cf03bba33033581bdc5d2727"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ad52599d1cf03bba33033581bdc5d2727">averageData</a> (gc::MeshData&lt; E, T &gt; &amp;meshData, const E &amp;element1, const E &amp;element2, const E &amp;newElement)</td></tr>
<tr class="memdesc:ad52599d1cf03bba33033581bdc5d2727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get average data.  <a href="namespacemem3dg.html#ad52599d1cf03bba33033581bdc5d2727">More...</a><br /></td></tr>
<tr class="separator:ad52599d1cf03bba33033581bdc5d2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b9b70537ff282c7d236cac21971017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> gc::Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a79b9b70537ff282c7d236cac21971017">cartesianToBarycentric</a> (gc::Vector2 &amp;v1, gc::Vector2 &amp;v2, gc::Vector2 &amp;v3, gc::Vector2 &amp;v)</td></tr>
<tr class="memdesc:a79b9b70537ff282c7d236cac21971017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert cartesian coordinates to barycentric coordinates.  <a href="namespacemem3dg.html#a79b9b70537ff282c7d236cac21971017">More...</a><br /></td></tr>
<tr class="separator:a79b9b70537ff282c7d236cac21971017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5067bc78dc736b750380aa03239f0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> gc::Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ad5067bc78dc736b750380aa03239f0f8">correspondBarycentricCoordinates</a> (const gc::Vector3 baryCoords_, const gcs::Halfedge &amp;firstHalfedge)</td></tr>
<tr class="memdesc:ad5067bc78dc736b750380aa03239f0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get corresponding barycentric coordinate to a face.  <a href="namespacemem3dg.html#ad5067bc78dc736b750380aa03239f0f8">More...</a><br /></td></tr>
<tr class="separator:ad5067bc78dc736b750380aa03239f0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aad8d84bad4158ba2b0b18b8e88a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> gc::Vector3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a41aad8d84bad4158ba2b0b18b8e88a20">vecFromHalfedge</a> (const gcs::Halfedge &amp;he, const gcs::VertexPositionGeometry &amp;vpg)</td></tr>
<tr class="memdesc:a41aad8d84bad4158ba2b0b18b8e88a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vector from halfedge vertices.  <a href="namespacemem3dg.html#a41aad8d84bad4158ba2b0b18b8e88a20">More...</a><br /></td></tr>
<tr class="separator:a41aad8d84bad4158ba2b0b18b8e88a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92e4803468c9b5979fbcd4b30d95475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ad92e4803468c9b5979fbcd4b30d95475">computePolygonArea</a> (const gcs::BoundaryLoop &amp;bl, const gcs::VertexData&lt; gc::Vector3 &gt; &amp;inputVertexPositions)</td></tr>
<tr class="memdesc:ad92e4803468c9b5979fbcd4b30d95475"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for computing the polygon area enclosed by a boundary loop on a mesh  <a href="namespacemem3dg.html#ad92e4803468c9b5979fbcd4b30d95475">More...</a><br /></td></tr>
<tr class="separator:ad92e4803468c9b5979fbcd4b30d95475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaf6307490f52ba758f71fd7da9a69f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#aaeaf6307490f52ba758f71fd7da9a69f">getTuftedLaplacianAndMass</a> (Eigen::SparseMatrix&lt; double &gt; &amp;M, Eigen::SparseMatrix&lt; double &gt; &amp;L, gcs::SurfaceMesh &amp;mesh, gcs::VertexPositionGeometry &amp;vpg)</td></tr>
<tr class="memdesc:aaeaf6307490f52ba758f71fd7da9a69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper function for constructing tufted laplacian and mass matrix  <a href="namespacemem3dg.html#aaeaf6307490f52ba758f71fd7da9a69f">More...</a><br /></td></tr>
<tr class="separator:aaeaf6307490f52ba758f71fd7da9a69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af651a0ec54313a330398dc5673e36016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#af651a0ec54313a330398dc5673e36016">boundaryProteinMask</a> (gcs::SurfaceMesh &amp;mesh, gcs::VertexData&lt; double &gt; &amp;mask, std::string boundaryConditionType)</td></tr>
<tr class="memdesc:af651a0ec54313a330398dc5673e36016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply boundary condition mask based on boundary condition type.  <a href="namespacemem3dg.html#af651a0ec54313a330398dc5673e36016">More...</a><br /></td></tr>
<tr class="separator:af651a0ec54313a330398dc5673e36016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe02625a2a7e70689d6da3c36f96f898"><td class="memItemLeft" align="right" valign="top"><a id="afe02625a2a7e70689d6da3c36f96f898"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>boundaryForceMask</b> (gcs::SurfaceMesh &amp;mesh, gcs::VertexData&lt; gc::Vector3 &gt; &amp;mask, std::string boundaryConditionType)</td></tr>
<tr class="separator:afe02625a2a7e70689d6da3c36f96f898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46177816228a2bf29b8209b617a5e30c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a46177816228a2bf29b8209b617a5e30c">removeTranslation</a> (Eigen::Ref&lt; EigenVectorX3dr &gt; force)</td></tr>
<tr class="memdesc:a46177816228a2bf29b8209b617a5e30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove rigid body translation.  <a href="namespacemem3dg.html#a46177816228a2bf29b8209b617a5e30c">More...</a><br /></td></tr>
<tr class="separator:a46177816228a2bf29b8209b617a5e30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956dce1d0d2441495fa8e1095e8f19b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a956dce1d0d2441495fa8e1095e8f19b4">removeRotation</a> (const Eigen::Ref&lt; const EigenVectorX3dr &gt; &amp;position, Eigen::Ref&lt; EigenVectorX3dr &gt; force)</td></tr>
<tr class="memdesc:a956dce1d0d2441495fa8e1095e8f19b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the rigid body Rotation.  <a href="namespacemem3dg.html#a956dce1d0d2441495fa8e1095e8f19b4">More...</a><br /></td></tr>
<tr class="separator:a956dce1d0d2441495fa8e1095e8f19b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f35e658b00732dbaff2ef361452dfec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a8f35e658b00732dbaff2ef361452dfec">gaussianDistribution</a> (const double &amp;distance, const double &amp;stdDev)</td></tr>
<tr class="memdesc:a8f35e658b00732dbaff2ef361452dfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian distribution.  <a href="namespacemem3dg.html#a8f35e658b00732dbaff2ef361452dfec">More...</a><br /></td></tr>
<tr class="separator:a8f35e658b00732dbaff2ef361452dfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dc114e171dcf2ae25d343ddeb3baab"><td class="memItemLeft" align="right" valign="top"><a id="ad1dc114e171dcf2ae25d343ddeb3baab"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>gaussianDistribution</b> (const double &amp;distance, const gc::Vector3 &amp;vertexPositionFromPtInd, const std::array&lt; gc::Vector3, 2 &gt; &amp;tangentBasis, const std::array&lt; double, 2 &gt; &amp;stdDev)</td></tr>
<tr class="separator:ad1dc114e171dcf2ae25d343ddeb3baab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cfb2acfed101b7d1aa200991f152d4"><td class="memItemLeft" align="right" valign="top"><a id="a58cfb2acfed101b7d1aa200991f152d4"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>gaussianDistribution</b> (Eigen::Ref&lt; EigenVectorX1d &gt; distribution, const Eigen::Ref&lt; const EigenVectorX1d &gt; &amp;distances, const double stdDev)</td></tr>
<tr class="separator:a58cfb2acfed101b7d1aa200991f152d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fa113052d123e9f2f17f5a47c97d81"><td class="memItemLeft" align="right" valign="top"><a id="aa1fa113052d123e9f2f17f5a47c97d81"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>gaussianDistribution</b> (EigenVectorX1d &amp;distribution, const Eigen::Ref&lt; const EigenVectorX1d &gt; &amp;distances, const gcs::VertexData&lt; gc::Vector3 &gt; &amp;vertexPositionsFromPtInd, const std::array&lt; gc::Vector3, 2 &gt; &amp;tangentBasis, const std::array&lt; double, 2 &gt; &amp;stdDev)</td></tr>
<tr class="separator:aa1fa113052d123e9f2f17f5a47c97d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cca0cec165a3205e256b333eee4f983"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a4cca0cec165a3205e256b333eee4f983">tanhDistribution</a> (const double &amp;distance, const double &amp;sharpness, const double &amp;ax)</td></tr>
<tr class="memdesc:a4cca0cec165a3205e256b333eee4f983"><td class="mdescLeft">&#160;</td><td class="mdescRight">height = 1 tanh step function with radius r  <a href="namespacemem3dg.html#a4cca0cec165a3205e256b333eee4f983">More...</a><br /></td></tr>
<tr class="separator:a4cca0cec165a3205e256b333eee4f983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53db1b4f054479ccde65b8c62d6956fd"><td class="memItemLeft" align="right" valign="top"><a id="a53db1b4f054479ccde65b8c62d6956fd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>tanhDistribution</b> (const double &amp;distance, const gc::Vector3 &amp;vertexPositionFromPtInd, const std::array&lt; gc::Vector3, 2 &gt; &amp;tangentBasis, const double &amp;sharpness, const std::array&lt; double, 2 &gt; &amp;axes)</td></tr>
<tr class="separator:a53db1b4f054479ccde65b8c62d6956fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54edf49035299437dab4fcf5bc62044d"><td class="memItemLeft" align="right" valign="top"><a id="a54edf49035299437dab4fcf5bc62044d"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>tanhDistribution</b> (Eigen::Ref&lt; EigenVectorX1d &gt; distribution, const Eigen::Ref&lt; const EigenVectorX1d &gt; &amp;distances, const double sharpness, const double &amp;ax)</td></tr>
<tr class="separator:a54edf49035299437dab4fcf5bc62044d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd4787cef6f222ee612b6f0cc18c44f"><td class="memItemLeft" align="right" valign="top"><a id="abfd4787cef6f222ee612b6f0cc18c44f"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>tanhDistribution</b> (EigenVectorX1d &amp;distribution, const Eigen::Ref&lt; const EigenVectorX1d &gt; &amp;distances, const gcs::VertexData&lt; gc::Vector3 &gt; &amp;vertexPositionsFromPtInd, const std::array&lt; gc::Vector3, 2 &gt; &amp;tangentBasis, const double sharpness, const std::array&lt; double, 2 &gt; &amp;axes)</td></tr>
<tr class="separator:abfd4787cef6f222ee612b6f0cc18c44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ab9482dbd348e142a9d31e7202207f"><td class="memItemLeft" align="right" valign="top"><a id="ae7ab9482dbd348e142a9d31e7202207f"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ae7ab9482dbd348e142a9d31e7202207f">sliceString</a> (std::string fileName, std::string delim1, std::string delim2)</td></tr>
<tr class="memdesc:ae7ab9482dbd348e142a9d31e7202207f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice string using two deliminator. <br /></td></tr>
<tr class="separator:ae7ab9482dbd348e142a9d31e7202207f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8cfbaf2d38126e3d59ff96442c9cf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a5f8cfbaf2d38126e3d59ff96442c9cf9">markFileName</a> (std::string filePath, std::string marker_str, std::string delimiter=&quot;.&quot;)</td></tr>
<tr class="memdesc:a5f8cfbaf2d38126e3d59ff96442c9cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the file name.  <a href="namespacemem3dg.html#a5f8cfbaf2d38126e3d59ff96442c9cf9">More...</a><br /></td></tr>
<tr class="separator:a5f8cfbaf2d38126e3d59ff96442c9cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9c8c0d6b6458838310533de7e565c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#aea9c8c0d6b6458838310533de7e565c1">jumpDistribution</a> (const double &amp;distance, const gc::Vector3 &amp;vertexPositionFromPtInd, const std::array&lt; gc::Vector3, 2 &gt; &amp;tangentBasis, const std::array&lt; double, 2 &gt; &amp;axes)</td></tr>
<tr class="memdesc:aea9c8c0d6b6458838310533de7e565c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">height = 1 for jump step domain  <a href="namespacemem3dg.html#aea9c8c0d6b6458838310533de7e565c1">More...</a><br /></td></tr>
<tr class="separator:aea9c8c0d6b6458838310533de7e565c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae09c994e7325c4a6664591baca5967"><td class="memItemLeft" align="right" valign="top"><a id="a1ae09c994e7325c4a6664591baca5967"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>jumpDistribution</b> (Eigen::Ref&lt; EigenVectorX1d &gt; distribution, const Eigen::Ref&lt; const EigenVectorX1d &gt; &amp;distances, const double &amp;ax)</td></tr>
<tr class="separator:a1ae09c994e7325c4a6664591baca5967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6dcbf4abbca3c1b635e05a294e622c"><td class="memItemLeft" align="right" valign="top"><a id="ade6dcbf4abbca3c1b635e05a294e622c"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><b>jumpDistribution</b> (EigenVectorX1d &amp;distribution, const Eigen::Ref&lt; const EigenVectorX1d &gt; &amp;distances, const gcs::VertexData&lt; gc::Vector3 &gt; &amp;vertexPositionsFromPtInd, const std::array&lt; gc::Vector3, 2 &gt; &amp;tangentBasis, const std::array&lt; double, 2 &gt; &amp;axes)</td></tr>
<tr class="separator:ade6dcbf4abbca3c1b635e05a294e622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50b6f25575f22f1e0292ddc27714abc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ab50b6f25575f22f1e0292ddc27714abc">processSoup</a> (std::string &amp;plyName)</td></tr>
<tr class="memdesc:ab50b6f25575f22f1e0292ddc27714abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">process vertex and face matrix soup from .ply file  <a href="namespacemem3dg.html#ab50b6f25575f22f1e0292ddc27714abc">More...</a><br /></td></tr>
<tr class="separator:ab50b6f25575f22f1e0292ddc27714abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f7c54a3be59e84731337408566b686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ac5f7c54a3be59e84731337408566b686">getFaceAndVertexMatrix</a> (std::string &amp;plyName)</td></tr>
<tr class="memdesc:ac5f7c54a3be59e84731337408566b686"><td class="mdescLeft">&#160;</td><td class="mdescRight">read vertex and face matrix from .ply file  <a href="namespacemem3dg.html#ac5f7c54a3be59e84731337408566b686">More...</a><br /></td></tr>
<tr class="separator:ac5f7c54a3be59e84731337408566b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bd336be603ec3acf610d649e2989fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a78bd336be603ec3acf610d649e2989fb">getDataElementName</a> (std::string &amp;plyName)</td></tr>
<tr class="memdesc:a78bd336be603ec3acf610d649e2989fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve all richData element name from .ply file. Namely the list of the places where data live in, such as vertex, edge or face.  <a href="namespacemem3dg.html#a78bd336be603ec3acf610d649e2989fb">More...</a><br /></td></tr>
<tr class="separator:a78bd336be603ec3acf610d649e2989fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ba230903e3e50fc2cc6269884d1fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a67ba230903e3e50fc2cc6269884d1fa2">getDataPropertyName</a> (std::string &amp;plyName, std::string &amp;elementName)</td></tr>
<tr class="separator:a67ba230903e3e50fc2cc6269884d1fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8dd8bca328e1ec2e09badf2f5ee4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a0d8dd8bca328e1ec2e09badf2f5ee4bc">getData</a> (std::string &amp;plyName, std::string &amp;elementName, std::string &amp;vertexProperties)</td></tr>
<tr class="separator:a0d8dd8bca328e1ec2e09badf2f5ee4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0b69f7c7ebba434f171ab148d5550b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt;, std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#aca0b69f7c7ebba434f171ab148d5550b">hexagon</a> (double R, int nSub)</td></tr>
<tr class="memdesc:aca0b69f7c7ebba434f171ab148d5550b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an hexagon mesh in PolygonSoup form.  <a href="namespacemem3dg.html#aca0b69f7c7ebba434f171ab148d5550b">More...</a><br /></td></tr>
<tr class="separator:aca0b69f7c7ebba434f171ab148d5550b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33fde42042a84c3c161926943a39cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ad33fde42042a84c3c161926943a39cf6">getHexagonMatrix</a> (double R, int nSub)</td></tr>
<tr class="memdesc:ad33fde42042a84c3c161926943a39cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an hexagon mesh in PolygonSoup form.  <a href="namespacemem3dg.html#ad33fde42042a84c3c161926943a39cf6">More...</a><br /></td></tr>
<tr class="separator:ad33fde42042a84c3c161926943a39cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7bb4d2a940fb7727296bcea6c10851"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt;, std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#aae7bb4d2a940fb7727296bcea6c10851">cylinder</a> (double R, int nR, int nh)</td></tr>
<tr class="memdesc:aae7bb4d2a940fb7727296bcea6c10851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an icosphere mesh in PolygonSoup form.  <a href="namespacemem3dg.html#aae7bb4d2a940fb7727296bcea6c10851">More...</a><br /></td></tr>
<tr class="separator:aae7bb4d2a940fb7727296bcea6c10851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1075ff7cac1b8230d06b57010d2ecea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a1075ff7cac1b8230d06b57010d2ecea6">getCylinderMatrix</a> (double R, int nR, int nh, double freq=1, double amp=0)</td></tr>
<tr class="memdesc:a1075ff7cac1b8230d06b57010d2ecea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an icosphere mesh in PolygonSoup form.  <a href="namespacemem3dg.html#a1075ff7cac1b8230d06b57010d2ecea6">More...</a><br /></td></tr>
<tr class="separator:a1075ff7cac1b8230d06b57010d2ecea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03e8c19616afd1a541ed0d0e0feed8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt;, std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ab03e8c19616afd1a541ed0d0e0feed8c">icosphere</a> (double R, int nSub)</td></tr>
<tr class="memdesc:ab03e8c19616afd1a541ed0d0e0feed8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an icosphere mesh in PolygonSoup form.  <a href="namespacemem3dg.html#ab03e8c19616afd1a541ed0d0e0feed8c">More...</a><br /></td></tr>
<tr class="separator:ab03e8c19616afd1a541ed0d0e0feed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6075382ca824dd972ed062f5efa623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#aff6075382ca824dd972ed062f5efa623">getIcosphereMatrix</a> (double R, int nSub)</td></tr>
<tr class="memdesc:aff6075382ca824dd972ed062f5efa623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an icosphere mesh.  <a href="namespacemem3dg.html#aff6075382ca824dd972ed062f5efa623">More...</a><br /></td></tr>
<tr class="separator:aff6075382ca824dd972ed062f5efa623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080de6b01da4e8729bc05a5d83cc9a59"><td class="memItemLeft" align="right" valign="top"><a id="a080de6b01da4e8729bc05a5d83cc9a59"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt;, std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a080de6b01da4e8729bc05a5d83cc9a59">tetrahedron</a> ()</td></tr>
<tr class="memdesc:a080de6b01da4e8729bc05a5d83cc9a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard code a tetrahedron in PolygonSoup form. <br /></td></tr>
<tr class="separator:a080de6b01da4e8729bc05a5d83cc9a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c8293f9a39f5819871594e4132a042"><td class="memItemLeft" align="right" valign="top"><a id="a57c8293f9a39f5819871594e4132a042"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a57c8293f9a39f5819871594e4132a042">getTetrahedronMatrix</a> ()</td></tr>
<tr class="memdesc:a57c8293f9a39f5819871594e4132a042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard code a tetrahedron in PolygonSoup form. <br /></td></tr>
<tr class="separator:a57c8293f9a39f5819871594e4132a042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d80bca82baaaedc863fac41692e71b"><td class="memItemLeft" align="right" valign="top"><a id="a69d80bca82baaaedc863fac41692e71b"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt;, std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a69d80bca82baaaedc863fac41692e71b">diamond</a> (double dihedral)</td></tr>
<tr class="memdesc:a69d80bca82baaaedc863fac41692e71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard code a diamond in PolygonSoup form. <br /></td></tr>
<tr class="separator:a69d80bca82baaaedc863fac41692e71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6419cf74db71e8baafe77f807eb96f"><td class="memItemLeft" align="right" valign="top"><a id="aac6419cf74db71e8baafe77f807eb96f"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#aac6419cf74db71e8baafe77f807eb96f">getDiamondMatrix</a> (double dihedral)</td></tr>
<tr class="memdesc:aac6419cf74db71e8baafe77f807eb96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard code a diamond in PolygonSoup form. <br /></td></tr>
<tr class="separator:aac6419cf74db71e8baafe77f807eb96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7481f869a0fa4fdd0fc56f932f4349d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a7481f869a0fa4fdd0fc56f932f4349d9">linearSubdivide</a> (std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt; &amp;mesh, std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &amp;vpg, std::size_t nSub)</td></tr>
<tr class="memdesc:a7481f869a0fa4fdd0fc56f932f4349d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide a manifold mesh.  <a href="namespacemem3dg.html#a7481f869a0fa4fdd0fc56f932f4349d9">More...</a><br /></td></tr>
<tr class="separator:a7481f869a0fa4fdd0fc56f932f4349d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7867cbb0e2a30c531e4d434b528bc5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ae7867cbb0e2a30c531e4d434b528bc5b">linearSubdivide</a> (Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt; &amp;faces, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &amp;coords, std::size_t nSub)</td></tr>
<tr class="memdesc:ae7867cbb0e2a30c531e4d434b528bc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide a mesh in Polygon Soup form.  <a href="namespacemem3dg.html#ae7867cbb0e2a30c531e4d434b528bc5b">More...</a><br /></td></tr>
<tr class="separator:ae7867cbb0e2a30c531e4d434b528bc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522eb43009df955c96326a367cc97c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a522eb43009df955c96326a367cc97c76">loopSubdivide</a> (std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt; &amp;ptrMesh, std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &amp;ptrVpg, std::size_t nSub)</td></tr>
<tr class="memdesc:a522eb43009df955c96326a367cc97c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide a manifold mesh in Loop scheme.  <a href="namespacemem3dg.html#a522eb43009df955c96326a367cc97c76">More...</a><br /></td></tr>
<tr class="separator:a522eb43009df955c96326a367cc97c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ce48fa964f1dfdc505a114d77abbc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt;, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ab6ce48fa964f1dfdc505a114d77abbc0">loopSubdivide</a> (Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt; &amp;faces, Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &amp;coords, std::size_t nSub)</td></tr>
<tr class="memdesc:ab6ce48fa964f1dfdc505a114d77abbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform loop subdivision on a Polygon Soup mesh.  <a href="namespacemem3dg.html#ab6ce48fa964f1dfdc505a114d77abbc0">More...</a><br /></td></tr>
<tr class="separator:ab6ce48fa964f1dfdc505a114d77abbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06734bef3dd80deb9dde040282c062f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::size_t, std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a06734bef3dd80deb9dde040282c062f5">getFaceSurfacePointClosestToEmbeddedCoordinate</a> (gcs::VertexPositionGeometry &amp;vpg, const std::array&lt; double, 3 &gt; &amp;embeddedCoordinate_, const Eigen::Matrix&lt; bool, Eigen::Dynamic, 1 &gt; &amp;filter, const std::array&lt; bool, 3 &gt; &amp;accountedCoordinate=std::array&lt; bool, 3 &gt;{ true, true, true})</td></tr>
<tr class="memdesc:a06734bef3dd80deb9dde040282c062f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the face index and the barycentric coordinate of the face surface point closest to a embedded coordinate in Euclidean distance.  <a href="namespacemem3dg.html#a06734bef3dd80deb9dde040282c062f5">More...</a><br /></td></tr>
<tr class="separator:a06734bef3dd80deb9dde040282c062f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b3d1d1c1a7e31f649ca54cb44575da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::size_t, std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ab0b3d1d1c1a7e31f649ca54cb44575da">getFaceSurfacePointClosestToEmbeddedCoordinate</a> (const EigenVectorX3sr &amp;faceMatrix, const EigenVectorX3dr &amp;vertexMatrix, const std::array&lt; double, 3 &gt; &amp;embeddedCoordinate, const Eigen::Matrix&lt; bool, Eigen::Dynamic, 1 &gt; &amp;filter, const std::array&lt; bool, 3 &gt; &amp;accountedCoordinate=std::array&lt; bool, 3 &gt;{ true, true, true})</td></tr>
<tr class="memdesc:ab0b3d1d1c1a7e31f649ca54cb44575da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the face index and the barycentric coordinate of the face surface point closest to a embedded coordinate in Euclidean distance.  <a href="namespacemem3dg.html#ab0b3d1d1c1a7e31f649ca54cb44575da">More...</a><br /></td></tr>
<tr class="separator:ab0b3d1d1c1a7e31f649ca54cb44575da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c924f6897ad48161a23547a3f130ac1"><td class="memItemLeft" align="right" valign="top"><a id="a0c924f6897ad48161a23547a3f130ac1"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt; std::size_t, std::array&lt; double, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getFaceSurfacePointClosestToEmbeddedCoordinate</b> (const EigenVectorX3sr &amp;faceMatrix, const EigenVectorX3dr &amp;vertexMatrix, const std::array&lt; double, 3 &gt; &amp;embeddedCoordinate, const std::array&lt; bool, 3 &gt; &amp;accountedCoordinate=std::array&lt; bool, 3 &gt;{ true, true, true})</td></tr>
<tr class="separator:a0c924f6897ad48161a23547a3f130ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3c97613ec29554a3aba71f24cf8aff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#a3c3c97613ec29554a3aba71f24cf8aff">getVertexClosestToEmbeddedCoordinate</a> (const EigenVectorX3dr &amp;vertexMatrix, const std::array&lt; double, 3 &gt; &amp;embeddedCoordinate, const Eigen::Matrix&lt; bool, Eigen::Dynamic, 1 &gt; &amp;filter, const std::array&lt; bool, 3 &gt; &amp;accountedCoordinate=std::array&lt; bool, 3 &gt;{ true, true, true})</td></tr>
<tr class="memdesc:a3c3c97613ec29554a3aba71f24cf8aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the vertex closest to a embedded coordinate in Euclidean distance.  <a href="namespacemem3dg.html#a3c3c97613ec29554a3aba71f24cf8aff">More...</a><br /></td></tr>
<tr class="separator:a3c3c97613ec29554a3aba71f24cf8aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8547bea6b9943d205940d6c4c690c6"><td class="memItemLeft" align="right" valign="top"><a id="afa8547bea6b9943d205940d6c4c690c6"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexClosestToEmbeddedCoordinate</b> (const EigenVectorX3dr &amp;vertexMatrix, const std::array&lt; double, 3 &gt; &amp;embeddedCoordinate, const std::array&lt; bool, 3 &gt; &amp;accountedCoordinate=std::array&lt; bool, 3 &gt;{ true, true, true})</td></tr>
<tr class="separator:afa8547bea6b9943d205940d6c4c690c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a5cd023df49f1fe5430adb543a00ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemem3dg.html#ae4a5cd023df49f1fe5430adb543a00ff">getVertexFurthestFromBoundary</a> (gc::ManifoldSurfaceMesh &amp;mesh, gc::VertexPositionGeometry &amp;vpg)</td></tr>
<tr class="memdesc:ae4a5cd023df49f1fe5430adb543a00ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the vertex furthest away from the boundaries.  <a href="namespacemem3dg.html#ae4a5cd023df49f1fe5430adb543a00ff">More...</a><br /></td></tr>
<tr class="separator:ae4a5cd023df49f1fe5430adb543a00ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e994c03822028094dd5b6a3dd4b519"><td class="memItemLeft" align="right" valign="top"><a id="aa3e994c03822028094dd5b6a3dd4b519"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexFurthestFromBoundary</b> (const EigenVectorX3sr &amp;faceMatrix, const EigenVectorX3dr &amp;vertexMatrix)</td></tr>
<tr class="separator:aa3e994c03822028094dd5b6a3dd4b519"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab9d9affda2a164f420e50cd4b42e58f0"><td class="memItemLeft" align="right" valign="top"><a id="ab9d9affda2a164f420e50cd4b42e58f0"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>MEM3DG_VERSION</b></td></tr>
<tr class="separator:ab9d9affda2a164f420e50cd4b42e58f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77568477a04ffca639beb1edf261647"><td class="memItemLeft" align="right" valign="top"><a id="ad77568477a04ffca639beb1edf261647"></a>
<a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>MEM3DG_VERSION_SHORT</b></td></tr>
<tr class="separator:ad77568477a04ffca639beb1edf261647"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Mem3dg namespace. </p>
<p><a class="el" href="namespacemem3dg.html" title="Mem3dg namespace.">mem3dg</a> namespace </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac18a4bfe1760e62b47f5c672c4e6ccb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18a4bfe1760e62b47f5c672c4e6ccb9">&#9670;&nbsp;</a></span>AlignedEigenMap_T</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t k, int Options = Eigen::ColMajor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">mem3dg::AlignedEigenMap_T</a> = typedef Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, k, Options&gt;, Eigen::AlignedMax&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typename for an Eigen map to an aligned raw buffer. </p>
<p>This assumes that the underlying buffer is aligned with Eigen::AlignedMax. Unfortunately it doesn't seem that the compiler can infer the alignment of the data for you.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the contained data </td></tr>
    <tr><td class="paramname">k</td><td>Number of columns </td></tr>
    <tr><td class="paramname">Options</td><td>Storage order <b>Eigen::RowMajor</b> or <b>Eigen::ColMajor</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9360091ae70efb3cb3ee7f85210c3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9360091ae70efb3cb3ee7f85210c3a7">&#9670;&nbsp;</a></span>ConstAlignedEigenMap_T</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t k, int Options = Eigen::ColMajor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">mem3dg::ConstAlignedEigenMap_T</a> = typedef Eigen::Map&lt;const Eigen::Matrix&lt;T, Eigen::Dynamic, k, Options&gt;, Eigen::AlignedMax&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typename for an Eigen map to a const aligned raw buffer. </p>
<p>This assumes that the underlying buffer is aligned with Eigen::AlignedMax. Unfortunately it doesn't seem that the compiler can infer the alignment of the data for you.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the contained data </td></tr>
    <tr><td class="paramname">k</td><td>Number of columns </td></tr>
    <tr><td class="paramname">Options</td><td>Storage order <b>Eigen::RowMajor</b> or <b>Eigen::ColMajor</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad52599d1cf03bba33033581bdc5d2727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52599d1cf03bba33033581bdc5d2727">&#9670;&nbsp;</a></span>averageData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::averageData </td>
          <td>(</td>
          <td class="paramtype">gc::MeshData&lt; E, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>element1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>element2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>newElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get average data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshData</td><td></td></tr>
    <tr><td class="paramname">element1</td><td></td></tr>
    <tr><td class="paramname">element2</td><td></td></tr>
    <tr><td class="paramname">newElement</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af651a0ec54313a330398dc5673e36016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af651a0ec54313a330398dc5673e36016">&#9670;&nbsp;</a></span>boundaryProteinMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::boundaryProteinMask </td>
          <td>(</td>
          <td class="paramtype">gcs::SurfaceMesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcs::VertexData&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>boundaryConditionType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply boundary condition mask based on boundary condition type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td></td></tr>
    <tr><td class="paramname">mask</td><td></td></tr>
    <tr><td class="paramname">boundaryConditionType</td><td>dirichlet or neumann </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79b9b70537ff282c7d236cac21971017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b9b70537ff282c7d236cac21971017">&#9670;&nbsp;</a></span>cartesianToBarycentric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> gc::Vector3 mem3dg::cartesianToBarycentric </td>
          <td>(</td>
          <td class="paramtype">gc::Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gc::Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gc::Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gc::Vector2 &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert cartesian coordinates to barycentric coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The first basis </td></tr>
    <tr><td class="paramname">v2</td><td>The second basis </td></tr>
    <tr><td class="paramname">v3</td><td>The third basis </td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DLL_PUBLIC </dd></dl>

</div>
</div>
<a id="ad92e4803468c9b5979fbcd4b30d95475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92e4803468c9b5979fbcd4b30d95475">&#9670;&nbsp;</a></span>computePolygonArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double mem3dg::computePolygonArea </td>
          <td>(</td>
          <td class="paramtype">const gcs::BoundaryLoop &amp;&#160;</td>
          <td class="paramname"><em>bl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gcs::VertexData&lt; gc::Vector3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputVertexPositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function for computing the polygon area enclosed by a boundary loop on a mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bl</td><td>boundary loop on a mesh </td></tr>
    <tr><td class="paramname">inputVertexPosition</td><td>embedded vertex position of the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enclosed polygon area </dd></dl>

</div>
</div>
<a id="ad5067bc78dc736b750380aa03239f0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5067bc78dc736b750380aa03239f0f8">&#9670;&nbsp;</a></span>correspondBarycentricCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> gc::Vector3 mem3dg::correspondBarycentricCoordinates </td>
          <td>(</td>
          <td class="paramtype">const gc::Vector3&#160;</td>
          <td class="paramname"><em>baryCoords_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gcs::Halfedge &amp;&#160;</td>
          <td class="paramname"><em>firstHalfedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get corresponding barycentric coordinate to a face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baryCoords</td><td>reference to Barycentric coordinate </td></tr>
    <tr><td class="paramname">firstHalfedge</td><td>reference to the halfedge associated with the first vertex of the Barycentric coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aae7bb4d2a940fb7727296bcea6c10851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7bb4d2a940fb7727296bcea6c10851">&#9670;&nbsp;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;std::unique_ptr&lt;gcs::ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;gcs::VertexPositionGeometry&gt; &gt; mem3dg::cylinder </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an icosphere mesh in PolygonSoup form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Radius of the the cylinder </td></tr>
    <tr><td class="paramname">nR</td><td>Number of element radially </td></tr>
    <tr><td class="paramname">nh</td><td>Number of element axially </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a530446a95ff172c5c99a0c66a193d787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530446a95ff172c5c99a0c66a193d787">&#9670;&nbsp;</a></span>EigenMap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t k, typename O , int Options = Eigen::RowMajor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt;T, k, Options&gt; mem3dg::EigenMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an Eigen Map to an aligned raw buffer. </p>
<p>This function will force cast the data from O to type T if O is a POD type. Reads the data in Row Major order by default since expansion of O to k*T occurs by row in theory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the output data </td></tr>
    <tr><td class="paramname">k</td><td>Number of columns in the output </td></tr>
    <tr><td class="paramname">O</td><td>Typename of the input data </td></tr>
    <tr><td class="paramname">Options</td><td>Storage order <b>Eigen::RowMajor</b> or <b>Eigen::ColMajor</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AlignedEigenMap_T&lt;T, k&gt; Eigen map object to the buffer </dd></dl>

</div>
</div>
<a id="af0ef136cba4f1f788cc54bde34c6fa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ef136cba4f1f788cc54bde34c6fa1e">&#9670;&nbsp;</a></span>EigenMap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt;T, 1&gt; mem3dg::EigenMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an Eigen Map to an aligned raw buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the output data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AlignedEigenMap_T&lt;T, 1&gt; Eigen map object to the buffer </dd></dl>

</div>
</div>
<a id="a405d04529e1fbbd4963bac9e4ec22443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405d04529e1fbbd4963bac9e4ec22443">&#9670;&nbsp;</a></span>EigenMap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t k, typename O , int Options = Eigen::RowMajor&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt;T, k, Options&gt; mem3dg::EigenMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an Eigen Map to a const aligned raw buffer. </p>
<p>This function will force cast the data from O to type T if O is a POD type. Reads the data in Row Major order by default since expansion of O to k*T occurs by row in theory.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the output data </td></tr>
    <tr><td class="paramname">k</td><td>Number of columns in the output </td></tr>
    <tr><td class="paramname">O</td><td>Typename of the input data </td></tr>
    <tr><td class="paramname">Options</td><td>Storage order <b>Eigen::RowMajor</b> or <b>Eigen::ColMajor</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ConstAlignedEigenMap_T&lt;T, k&gt; Eigen map object to the buffer </dd></dl>

</div>
</div>
<a id="a55ffb09c24a72ea4d8dbbf64e43560ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ffb09c24a72ea4d8dbbf64e43560ed">&#9670;&nbsp;</a></span>EigenMap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt;T, 1&gt; mem3dg::EigenMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an Eigen Map to an aligned raw buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the output data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AlignedEigenMap_T&lt;T, 1&gt; Eigen map object to the buffer </dd></dl>

</div>
</div>
<a id="ad6f6703fb26f37bc4b77007e4204ceda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f6703fb26f37bc4b77007e4204ceda">&#9670;&nbsp;</a></span>findMedianIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> int mem3dg::findMedianIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the middle index between two bounding indices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>left bound </td></tr>
    <tr><td class="paramname">r</td><td>right bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>middle index </dd></dl>

</div>
</div>
<a id="a7fa60ad9c6289417135e4c03ef3948c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa60ad9c6289417135e4c03ef3948c9">&#9670;&nbsp;</a></span>findRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::findRange </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>find the range of data based on percentile (quartile) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>raw buffer of vector </td></tr>
    <tr><td class="paramname">n</td><td>size of vector </td></tr>
    <tr><td class="paramname">r</td><td>upper bound of range </td></tr>
    <tr><td class="paramname">l</td><td>lower bound of range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa78531a57b0526c565190e07c3a89b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78531a57b0526c565190e07c3a89b69">&#9670;&nbsp;</a></span>flatten() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt;typename Derived::Scalar, 1, Eigen::ColMajor&gt; mem3dg::flatten </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; const Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten a NxK row matrix into KNx1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Typename of the Eigen dense type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7" title="Typename for an Eigen map to a const aligned raw buffer.">ConstAlignedEigenMap_T&lt;typename Derived::Scalar, 1, Eigen::ColMajor&gt;</a> Flattened result </dd></dl>

</div>
</div>
<a id="a3679a03c05b9b303f60e3a103b02d478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3679a03c05b9b303f60e3a103b02d478">&#9670;&nbsp;</a></span>flatten() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt;typename Derived::Scalar, 1, Eigen::ColMajor&gt; mem3dg::flatten </td>
          <td>(</td>
          <td class="paramtype">Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten a NxK row matrix into KNx1. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Typename of the Eigen dense type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9" title="Typename for an Eigen map to an aligned raw buffer.">AlignedEigenMap_T&lt;typename Derived::Scalar, 1&gt;</a> Flattened result </dd></dl>

</div>
</div>
<a id="a3954854d155a2c2e73daaba157bda79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3954854d155a2c2e73daaba157bda79e">&#9670;&nbsp;</a></span>FlattenedEigenMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t k, typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ac18a4bfe1760e62b47f5c672c4e6ccb9">AlignedEigenMap_T</a>&lt;T, 1&gt; mem3dg::FlattenedEigenMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an Eigen Map to an aligned raw buffer. </p>
<p>This function will force cast the data from O to type T if O is a POD type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the output data </td></tr>
    <tr><td class="paramname">k</td><td>Number of columns in the output </td></tr>
    <tr><td class="paramname">O</td><td>Typename of the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AlignedEigenMap_T&lt;T, k&gt; Eigen map object to the buffer </dd></dl>

</div>
</div>
<a id="a5a5e74c89ae7c026d3f7195fe8726188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5e74c89ae7c026d3f7195fe8726188">&#9670;&nbsp;</a></span>FlattenedEigenMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t k, typename O &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemem3dg.html#ad9360091ae70efb3cb3ee7f85210c3a7">ConstAlignedEigenMap_T</a>&lt;T, 1&gt; mem3dg::FlattenedEigenMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemem3dg.html#a4c1bfded48c3668f9b21cc259437fb7a">AlignedVector_T</a>&lt; O &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate an Eigen Map to an aligned raw buffer. </p>
<p>This function will force cast the data from O to type T if O is a POD type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Typename of the output data </td></tr>
    <tr><td class="paramname">k</td><td>Number of columns in the output </td></tr>
    <tr><td class="paramname">O</td><td>Typename of the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AlignedEigenMap_T&lt;T, k&gt; Eigen map object to the buffer </dd></dl>

</div>
</div>
<a id="a8f35e658b00732dbaff2ef361452dfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f35e658b00732dbaff2ef361452dfec">&#9670;&nbsp;</a></span>gaussianDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mem3dg::gaussianDistribution </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>stdDev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gaussian distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>vector </td></tr>
    <tr><td class="paramname">standard</td><td>deviation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1075ff7cac1b8230d06b57010d2ecea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1075ff7cac1b8230d06b57010d2ecea6">&#9670;&nbsp;</a></span>getCylinderMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;Eigen::Matrix&lt;std::size_t, Eigen::Dynamic, 3&gt;, Eigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; &gt; mem3dg::getCylinderMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>freq</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amp</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an icosphere mesh in PolygonSoup form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Radius of the the cylinder </td></tr>
    <tr><td class="paramname">nR</td><td>Number of element radially </td></tr>
    <tr><td class="paramname">nh</td><td>Number of element axially </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d8dd8bca328e1ec2e09badf2f5ee4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8dd8bca328e1ec2e09badf2f5ee4bc">&#9670;&nbsp;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt; mem3dg::getData </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>plyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>vertexProperties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plyName</td><td></td></tr>
    <tr><td class="paramname">elementName</td><td></td></tr>
    <tr><td class="paramname">vertexProperties</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a78bd336be603ec3acf610d649e2989fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bd336be603ec3acf610d649e2989fb">&#9670;&nbsp;</a></span>getDataElementName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::vector&lt;std::string&gt; mem3dg::getDataElementName </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>plyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve all richData element name from .ply file. Namely the list of the places where data live in, such as vertex, edge or face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plyName</td><td>PLY file to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of all element names </dd></dl>

</div>
</div>
<a id="a67ba230903e3e50fc2cc6269884d1fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ba230903e3e50fc2cc6269884d1fa2">&#9670;&nbsp;</a></span>getDataPropertyName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::vector&lt;std::string&gt; mem3dg::getDataPropertyName </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>plyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plyName</td><td></td></tr>
    <tr><td class="paramname">elementName</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac5f7c54a3be59e84731337408566b686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f7c54a3be59e84731337408566b686">&#9670;&nbsp;</a></span>getFaceAndVertexMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;Eigen::Matrix&lt;size_t, Eigen::Dynamic, 3&gt;, Eigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; &gt; mem3dg::getFaceAndVertexMatrix </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>plyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read vertex and face matrix from .ply file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plyName</td><td>path to the .ply file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of processed face topology matrix and vertex position matrix </dd></dl>

</div>
</div>
<a id="ab0b3d1d1c1a7e31f649ca54cb44575da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b3d1d1c1a7e31f649ca54cb44575da">&#9670;&nbsp;</a></span>getFaceSurfacePointClosestToEmbeddedCoordinate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;std::size_t, std::array&lt;double, 3&gt; &gt; mem3dg::getFaceSurfacePointClosestToEmbeddedCoordinate </td>
          <td>(</td>
          <td class="paramtype">const EigenVectorX3sr &amp;&#160;</td>
          <td class="paramname"><em>faceMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EigenVectorX3dr &amp;&#160;</td>
          <td class="paramname"><em>vertexMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>embeddedCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>accountedCoordinate</em> = <code>std::array&lt;&#160;bool,&#160;3&#160;&gt;{&#160;true,&#160;true,&#160;true}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the face index and the barycentric coordinate of the face surface point closest to a embedded coordinate in Euclidean distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faceMatrix</td><td>face topology matrix of the mesh (F x 3) </td></tr>
    <tr><td class="paramname">vertexMatrix</td><td>vertex position matrix of the mesh (V x 3) </td></tr>
    <tr><td class="paramname">embeddedCoordinate</td><td>the target embedded coordinate expressed in 3D cartesian coordinate </td></tr>
    <tr><td class="paramname">filter</td><td>Limit the scope of search to a subset of vertices, Defaults to all true by overloading </td></tr>
    <tr><td class="paramname">accountedCoordinate</td><td>array to identify the accounted coordinate. For example, it finds closest vertex in the x-y plane when set to be {true, true, false}. Defaults to {true, true, true}</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of face index and the barycentric coordinate </dd></dl>

</div>
</div>
<a id="a06734bef3dd80deb9dde040282c062f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06734bef3dd80deb9dde040282c062f5">&#9670;&nbsp;</a></span>getFaceSurfacePointClosestToEmbeddedCoordinate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;std::size_t, std::array&lt;double, 3&gt; &gt; mem3dg::getFaceSurfacePointClosestToEmbeddedCoordinate </td>
          <td>(</td>
          <td class="paramtype">gcs::VertexPositionGeometry &amp;&#160;</td>
          <td class="paramname"><em>vpg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>embeddedCoordinate_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>accountedCoordinate</em> = <code>std::array&lt;&#160;bool,&#160;3&#160;&gt;{&#160;true,&#160;true,&#160;true}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the face index and the barycentric coordinate of the face surface point closest to a embedded coordinate in Euclidean distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpg</td><td>vertex position geometry </td></tr>
    <tr><td class="paramname">embeddedCoordinate</td><td>the target embedded coordinate expressed in 3D cartesian coordinate </td></tr>
    <tr><td class="paramname">accountedCoordinate</td><td>array to identify the accounted coordinate. For example, it finds closest vertex in the x-y plane when set to be {true, true, false}. Defaults to {true, true, true} </td></tr>
    <tr><td class="paramname">filter</td><td>Limit the scope of search to a subset of vertices, Defaults to all true by overloading </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of face index and the barycentric coordinate </dd></dl>

</div>
</div>
<a id="ad33fde42042a84c3c161926943a39cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33fde42042a84c3c161926943a39cf6">&#9670;&nbsp;</a></span>getHexagonMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;Eigen::Matrix&lt;std::size_t, Eigen::Dynamic, 3&gt;, Eigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; &gt; mem3dg::getHexagonMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an hexagon mesh in PolygonSoup form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Radius of the the hexagon </td></tr>
    <tr><td class="paramname">nSub</td><td>Number of subdivision </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff6075382ca824dd972ed062f5efa623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6075382ca824dd972ed062f5efa623">&#9670;&nbsp;</a></span>getIcosphereMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;Eigen::Matrix&lt;std::size_t, Eigen::Dynamic, 3&gt;, Eigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; &gt; mem3dg::getIcosphereMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an icosphere mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Radius of the icosphere </td></tr>
    <tr><td class="paramname">nSub</td><td>Iterations of quadrisections to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b23a08e81f455399546903f396a1135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b23a08e81f455399546903f396a1135">&#9670;&nbsp;</a></span>getMeshVolume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double mem3dg::getMeshVolume </td>
          <td>(</td>
          <td class="paramtype">gcs::ManifoldSurfaceMesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcs::VertexPositionGeometry &amp;&#160;</td>
          <td class="paramname"><em>vpg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFillHole</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the volume of a mesh object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Manifold surface mesh topology </td></tr>
    <tr><td class="paramname">vpg</td><td>The vertex position geometry of the mesh </td></tr>
    <tr><td class="paramname">isFillHole</td><td>Flag for filling holes in open mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed volume of the geometry </dd></dl>

</div>
</div>
<a id="aaeaf6307490f52ba758f71fd7da9a69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeaf6307490f52ba758f71fd7da9a69f">&#9670;&nbsp;</a></span>getTuftedLaplacianAndMass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::getTuftedLaplacianAndMass </td>
          <td>(</td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcs::SurfaceMesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcs::VertexPositionGeometry &amp;&#160;</td>
          <td class="paramname"><em>vpg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper function for constructing tufted laplacian and mass matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mass</td><td>matrix M </td></tr>
    <tr><td class="paramname">Laplacian</td><td>matrix L </td></tr>
    <tr><td class="paramname">surfaceMesh</td><td>mesh </td></tr>
    <tr><td class="paramname">vertexPositionGeometry</td><td>vpg </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c3c97613ec29554a3aba71f24cf8aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3c97613ec29554a3aba71f24cf8aff">&#9670;&nbsp;</a></span>getVertexClosestToEmbeddedCoordinate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::size_t mem3dg::getVertexClosestToEmbeddedCoordinate </td>
          <td>(</td>
          <td class="paramtype">const EigenVectorX3dr &amp;&#160;</td>
          <td class="paramname"><em>vertexMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>embeddedCoordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; bool, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>accountedCoordinate</em> = <code>std::array&lt;&#160;bool,&#160;3&#160;&gt;{&#160;true,&#160;true,&#160;true}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the vertex closest to a embedded coordinate in Euclidean distance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexMatrix</td><td>vertex position matrix of the mesh (N x 3) </td></tr>
    <tr><td class="paramname">embeddedCoordinate</td><td>the target embedded coordinate expressed in 3D cartesian coordinate </td></tr>
    <tr><td class="paramname">accountedCoordinate</td><td>array to identify the accounted coordinate. For example, it finds closest vertex in the x-y plane when set to be {true, true, false}. Defaults to {true, true, true} </td></tr>
    <tr><td class="paramname">filter</td><td>Limit the scope of search to a subset of vertices, Defaults to all true by overloading</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vertex index </dd></dl>

</div>
</div>
<a id="ae4a5cd023df49f1fe5430adb543a00ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a5cd023df49f1fe5430adb543a00ff">&#9670;&nbsp;</a></span>getVertexFurthestFromBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::size_t mem3dg::getVertexFurthestFromBoundary </td>
          <td>(</td>
          <td class="paramtype">gc::ManifoldSurfaceMesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gc::VertexPositionGeometry &amp;&#160;</td>
          <td class="paramname"><em>vpg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the vertex furthest away from the boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>surface mesh </td></tr>
    <tr><td class="paramname">vpg</td><td>vertex position geometry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vertex index </dd></dl>

</div>
</div>
<a id="a5cce18eb8259594b2540130536a38b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cce18eb8259594b2540130536a38b2a">&#9670;&nbsp;</a></span>hasOutlier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> bool mem3dg::hasOutlier </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test whether exist outliers to the set of data based range function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>data vector </td></tr>
    <tr><td class="paramname">threshold</td><td>coefficient used to bound the outlier. For example: (Outlier &lt;--&gt; r) &lt; [threshold * (l &lt;--&gt; r)] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aca0b69f7c7ebba434f171ab148d5550b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0b69f7c7ebba434f171ab148d5550b">&#9670;&nbsp;</a></span>hexagon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;std::unique_ptr&lt;gcs::ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;gcs::VertexPositionGeometry&gt; &gt; mem3dg::hexagon </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an hexagon mesh in PolygonSoup form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Radius of the the hexagon </td></tr>
    <tr><td class="paramname">nSub</td><td>Number of subdivision </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab03e8c19616afd1a541ed0d0e0feed8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03e8c19616afd1a541ed0d0e0feed8c">&#9670;&nbsp;</a></span>icosphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;std::unique_ptr&lt;gcs::ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;gcs::VertexPositionGeometry&gt; &gt; mem3dg::icosphere </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an icosphere mesh in PolygonSoup form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>Radius of the icosphere </td></tr>
    <tr><td class="paramname">nSub</td><td>Iterations of quadrisections to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea9c8c0d6b6458838310533de7e565c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9c8c0d6b6458838310533de7e565c1">&#9670;&nbsp;</a></span>jumpDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double mem3dg::jumpDistribution </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gc::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>vertexPositionFromPtInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; gc::Vector3, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tangentBasis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>height = 1 for jump step domain </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(double)</td><td>sharpness of transition </td></tr>
    <tr><td class="paramname">(double)</td><td>radius of height = 1 </td></tr>
    <tr><td class="paramname">(Eigen</td><td>vector) distance vector </td></tr>
    <tr><td class="paramname">(vertexPositionGeometry)</td><td>vpg </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7867cbb0e2a30c531e4d434b528bc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7867cbb0e2a30c531e4d434b528bc5b">&#9670;&nbsp;</a></span>linearSubdivide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;Eigen::Matrix&lt;std::size_t, Eigen::Dynamic, 3&gt;, Eigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; &gt; mem3dg::linearSubdivide </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide a mesh in Polygon Soup form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td></td></tr>
    <tr><td class="paramname">coords</td><td></td></tr>
    <tr><td class="paramname">nSub</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7481f869a0fa4fdd0fc56f932f4349d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7481f869a0fa4fdd0fc56f932f4349d9">&#9670;&nbsp;</a></span>linearSubdivide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::linearSubdivide </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &amp;&#160;</td>
          <td class="paramname"><em>vpg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide a manifold mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Reference to the pointer to the mesh object </td></tr>
    <tr><td class="paramname">vpg</td><td>Reference to the pointer to the geometry object </td></tr>
    <tr><td class="paramname">nSub</td><td>Iterations of quadrisections to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6ce48fa964f1dfdc505a114d77abbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ce48fa964f1dfdc505a114d77abbc0">&#9670;&nbsp;</a></span>loopSubdivide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;Eigen::Matrix&lt;std::size_t, Eigen::Dynamic, 3&gt;, Eigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; &gt; mem3dg::loopSubdivide </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; std::size_t, Eigen::Dynamic, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform loop subdivision on a Polygon Soup mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">faces</td><td></td></tr>
    <tr><td class="paramname">coords</td><td></td></tr>
    <tr><td class="paramname">nSub</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a522eb43009df955c96326a367cc97c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522eb43009df955c96326a367cc97c76">&#9670;&nbsp;</a></span>loopSubdivide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::loopSubdivide </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; gcs::ManifoldSurfaceMesh &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptrMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; gcs::VertexPositionGeometry &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptrVpg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nSub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide a manifold mesh in Loop scheme. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Reference to the pointer to the mesh object </td></tr>
    <tr><td class="paramname">vpg</td><td>Reference to the pointer to the geometry object </td></tr>
    <tr><td class="paramname">nSub</td><td>Iterations of quadrisections to perform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f8cfbaf2d38126e3d59ff96442c9cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8cfbaf2d38126e3d59ff96442c9cf9">&#9670;&nbsp;</a></span>markFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::markFileName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>marker_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>&quot;.&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the file name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirPath</td><td>path of the directory </td></tr>
    <tr><td class="paramname">file</td><td>name of the file, for example in the form of "/traj.nc" </td></tr>
    <tr><td class="paramname">marker_str</td><td>marker used to mark the file, such as marker = "_failed" results in new file name of "/traj_failed.nc" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ac11c7670c0c87458b6aa536bb58c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac11c7670c0c87458b6aa536bb58c09">&#9670;&nbsp;</a></span>outlierMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> EigenVectorX1_T&lt;bool&gt; mem3dg::outlierMask </td>
          <td>(</td>
          <td class="paramtype">const EigenVectorX1d &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>negate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>test whether exist outliers to the set of data based range function </p>
<p>For example: (Outlier &lt;--&gt; r) &lt; [threshold * (l &lt;--&gt; r)]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>data vector </td></tr>
    <tr><td class="paramname">threshold</td><td>coefficient used to bound the outlier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mask </dd></dl>

</div>
</div>
<a id="ab50b6f25575f22f1e0292ddc27714abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50b6f25575f22f1e0292ddc27714abc">&#9670;&nbsp;</a></span>processSoup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> std::tuple&lt;Eigen::Matrix&lt;std::size_t, Eigen::Dynamic, 3&gt;, Eigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; &gt; mem3dg::processSoup </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>plyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>process vertex and face matrix soup from .ply file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plyName</td><td>path to the .ply file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple of processed face topology matrix and vertex position matrix </dd></dl>

</div>
</div>
<a id="a956dce1d0d2441495fa8e1095e8f19b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956dce1d0d2441495fa8e1095e8f19b4">&#9670;&nbsp;</a></span>removeRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::removeRotation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const EigenVectorX3dr &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; EigenVectorX3dr &gt;&#160;</td>
          <td class="paramname"><em>force</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the rigid body Rotation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Eigen</td><td>force matrix </td></tr>
    <tr><td class="paramname">Eigen</td><td>position matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46177816228a2bf29b8209b617a5e30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46177816228a2bf29b8209b617a5e30c">&#9670;&nbsp;</a></span>removeTranslation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::removeTranslation </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; EigenVectorX3dr &gt;&#160;</td>
          <td class="paramname"><em>force</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove rigid body translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>Matrix of forces to process </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1188f5bd2efed53cb4b223e12d4c22d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1188f5bd2efed53cb4b223e12d4c22d1">&#9670;&nbsp;</a></span>rowwiseCrossProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::PlainMatrix mem3dg::rowwiseCrossProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rowwise cross product between two matrices. </p>
<p>Note that this function does not return a result of an intermediate Eigen operation. Owing to some limitations, we return an evaluated temporary.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Template type value of the matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix A </td></tr>
    <tr><td class="paramname">B</td><td>Matrix B </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of rowwise cross products </dd></dl>

</div>
</div>
<a id="abf447d558909b0aa3d2ec070acb82614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf447d558909b0aa3d2ec070acb82614">&#9670;&nbsp;</a></span>rowwiseDotProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mem3dg::rowwiseDotProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rowwise dot product between two Eigen Matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedA</td><td>Template type value of matrix A </td></tr>
    <tr><td class="paramname">DerivedB</td><td>Template type value of matrix B </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the first matrix </td></tr>
    <tr><td class="paramname">B</td><td>The other matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto Intermediate return value for Eigen optimization </dd></dl>

</div>
</div>
<a id="a89367de57a1fb9f6a7399ac1f191be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89367de57a1fb9f6a7399ac1f191be5d">&#9670;&nbsp;</a></span>rowwiseScalarProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mem3dg::rowwiseScalarProduct </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; VectorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rowwise scalar product between a matrix and scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>Template type of vector type </td></tr>
    <tr><td class="paramname">Derived</td><td>Template type of matrix B </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The vector of scalar values </td></tr>
    <tr><td class="paramname">B</td><td>The vector of matrix values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto </dd></dl>

</div>
</div>
<a id="ac95cce8740048b09b90913fc1abba85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95cce8740048b09b90913fc1abba85c">&#9670;&nbsp;</a></span>signedVolumeFromFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> double mem3dg::signedVolumeFromFace </td>
          <td>(</td>
          <td class="paramtype">gc::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gc::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gc::Vector3 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get volume from a face. </p>
<dl class="section return"><dt>Returns</dt><dd>double </dd></dl>

</div>
</div>
<a id="a4833942188b5e9e6ff0a3723b423ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4833942188b5e9e6ff0a3723b423ddcf">&#9670;&nbsp;</a></span>sortVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::sortVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>sorted_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort Eigen vector from largest to smallest (overloaded) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector to be sorted </td></tr>
    <tr><td class="paramname">sorted_vec</td><td>sorted vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7c2ab9afa972ce74cef7bae4ca09ac7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ab9afa972ce74cef7bae4ca09ac7f">&#9670;&nbsp;</a></span>sortVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> void mem3dg::sortVector </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>sorted_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>ind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort Eigen vector from largest to smallest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>vector to be sorted </td></tr>
    <tr><td class="paramname">sorted_vec</td><td>sorted vector </td></tr>
    <tr><td class="paramname">ind</td><td>indices of sorted vector based on original vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4cca0cec165a3205e256b333eee4f983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cca0cec165a3205e256b333eee4f983">&#9670;&nbsp;</a></span>tanhDistribution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double mem3dg::tanhDistribution </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>sharpness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>height = 1 tanh step function with radius r </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sharpness</td><td>sharpness of transition </td></tr>
    <tr><td class="paramname">ax</td><td>radius of height = 1 </td></tr>
    <tr><td class="paramname">distance</td><td>distance vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41aad8d84bad4158ba2b0b18b8e88a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aad8d84bad4158ba2b0b18b8e88a20">&#9670;&nbsp;</a></span>vecFromHalfedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="macros_8h.html#a29047de4dfe891435d8254535634ac1d">DLL_PUBLIC</a> gc::Vector3 mem3dg::vecFromHalfedge </td>
          <td>(</td>
          <td class="paramtype">const gcs::Halfedge &amp;&#160;</td>
          <td class="paramname"><em>he</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gcs::VertexPositionGeometry &amp;&#160;</td>
          <td class="paramname"><em>vpg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the vector from halfedge vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">he</td><td></td></tr>
    <tr><td class="paramname">vpg</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gc::Vector3 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
